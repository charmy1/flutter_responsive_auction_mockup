// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'cart_presentation_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$CartPresentationEventTearOff {
  const _$CartPresentationEventTearOff();

// ignore: unused_element
  Summary summary() {
    return const Summary();
  }

// ignore: unused_element
  Address address() {
    return const Address();
  }

// ignore: unused_element
  Delivery delivery() {
    return const Delivery();
  }

// ignore: unused_element
  Payment payment() {
    return const Payment();
  }
}

/// @nodoc
// ignore: unused_element
const $CartPresentationEvent = _$CartPresentationEventTearOff();

/// @nodoc
mixin _$CartPresentationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult summary(),
    @required TResult address(),
    @required TResult delivery(),
    @required TResult payment(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult summary(),
    TResult address(),
    TResult delivery(),
    TResult payment(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult summary(Summary value),
    @required TResult address(Address value),
    @required TResult delivery(Delivery value),
    @required TResult payment(Payment value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult summary(Summary value),
    TResult address(Address value),
    TResult delivery(Delivery value),
    TResult payment(Payment value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CartPresentationEventCopyWith<$Res> {
  factory $CartPresentationEventCopyWith(CartPresentationEvent value,
          $Res Function(CartPresentationEvent) then) =
      _$CartPresentationEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$CartPresentationEventCopyWithImpl<$Res>
    implements $CartPresentationEventCopyWith<$Res> {
  _$CartPresentationEventCopyWithImpl(this._value, this._then);

  final CartPresentationEvent _value;
  // ignore: unused_field
  final $Res Function(CartPresentationEvent) _then;
}

/// @nodoc
abstract class $SummaryCopyWith<$Res> {
  factory $SummaryCopyWith(Summary value, $Res Function(Summary) then) =
      _$SummaryCopyWithImpl<$Res>;
}

/// @nodoc
class _$SummaryCopyWithImpl<$Res>
    extends _$CartPresentationEventCopyWithImpl<$Res>
    implements $SummaryCopyWith<$Res> {
  _$SummaryCopyWithImpl(Summary _value, $Res Function(Summary) _then)
      : super(_value, (v) => _then(v as Summary));

  @override
  Summary get _value => super._value as Summary;
}

/// @nodoc
class _$Summary implements Summary {
  const _$Summary();

  @override
  String toString() {
    return 'CartPresentationEvent.summary()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Summary);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult summary(),
    @required TResult address(),
    @required TResult delivery(),
    @required TResult payment(),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return summary();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult summary(),
    TResult address(),
    TResult delivery(),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (summary != null) {
      return summary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult summary(Summary value),
    @required TResult address(Address value),
    @required TResult delivery(Delivery value),
    @required TResult payment(Payment value),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return summary(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult summary(Summary value),
    TResult address(Address value),
    TResult delivery(Delivery value),
    TResult payment(Payment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (summary != null) {
      return summary(this);
    }
    return orElse();
  }
}

abstract class Summary implements CartPresentationEvent {
  const factory Summary() = _$Summary;
}

/// @nodoc
abstract class $AddressCopyWith<$Res> {
  factory $AddressCopyWith(Address value, $Res Function(Address) then) =
      _$AddressCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddressCopyWithImpl<$Res>
    extends _$CartPresentationEventCopyWithImpl<$Res>
    implements $AddressCopyWith<$Res> {
  _$AddressCopyWithImpl(Address _value, $Res Function(Address) _then)
      : super(_value, (v) => _then(v as Address));

  @override
  Address get _value => super._value as Address;
}

/// @nodoc
class _$Address implements Address {
  const _$Address();

  @override
  String toString() {
    return 'CartPresentationEvent.address()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Address);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult summary(),
    @required TResult address(),
    @required TResult delivery(),
    @required TResult payment(),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return address();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult summary(),
    TResult address(),
    TResult delivery(),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (address != null) {
      return address();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult summary(Summary value),
    @required TResult address(Address value),
    @required TResult delivery(Delivery value),
    @required TResult payment(Payment value),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return address(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult summary(Summary value),
    TResult address(Address value),
    TResult delivery(Delivery value),
    TResult payment(Payment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (address != null) {
      return address(this);
    }
    return orElse();
  }
}

abstract class Address implements CartPresentationEvent {
  const factory Address() = _$Address;
}

/// @nodoc
abstract class $DeliveryCopyWith<$Res> {
  factory $DeliveryCopyWith(Delivery value, $Res Function(Delivery) then) =
      _$DeliveryCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeliveryCopyWithImpl<$Res>
    extends _$CartPresentationEventCopyWithImpl<$Res>
    implements $DeliveryCopyWith<$Res> {
  _$DeliveryCopyWithImpl(Delivery _value, $Res Function(Delivery) _then)
      : super(_value, (v) => _then(v as Delivery));

  @override
  Delivery get _value => super._value as Delivery;
}

/// @nodoc
class _$Delivery implements Delivery {
  const _$Delivery();

  @override
  String toString() {
    return 'CartPresentationEvent.delivery()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Delivery);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult summary(),
    @required TResult address(),
    @required TResult delivery(),
    @required TResult payment(),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return delivery();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult summary(),
    TResult address(),
    TResult delivery(),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (delivery != null) {
      return delivery();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult summary(Summary value),
    @required TResult address(Address value),
    @required TResult delivery(Delivery value),
    @required TResult payment(Payment value),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return delivery(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult summary(Summary value),
    TResult address(Address value),
    TResult delivery(Delivery value),
    TResult payment(Payment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (delivery != null) {
      return delivery(this);
    }
    return orElse();
  }
}

abstract class Delivery implements CartPresentationEvent {
  const factory Delivery() = _$Delivery;
}

/// @nodoc
abstract class $PaymentCopyWith<$Res> {
  factory $PaymentCopyWith(Payment value, $Res Function(Payment) then) =
      _$PaymentCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentCopyWithImpl<$Res>
    extends _$CartPresentationEventCopyWithImpl<$Res>
    implements $PaymentCopyWith<$Res> {
  _$PaymentCopyWithImpl(Payment _value, $Res Function(Payment) _then)
      : super(_value, (v) => _then(v as Payment));

  @override
  Payment get _value => super._value as Payment;
}

/// @nodoc
class _$Payment implements Payment {
  const _$Payment();

  @override
  String toString() {
    return 'CartPresentationEvent.payment()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Payment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult summary(),
    @required TResult address(),
    @required TResult delivery(),
    @required TResult payment(),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return payment();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult summary(),
    TResult address(),
    TResult delivery(),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (payment != null) {
      return payment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult summary(Summary value),
    @required TResult address(Address value),
    @required TResult delivery(Delivery value),
    @required TResult payment(Payment value),
  }) {
    assert(summary != null);
    assert(address != null);
    assert(delivery != null);
    assert(payment != null);
    return payment(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult summary(Summary value),
    TResult address(Address value),
    TResult delivery(Delivery value),
    TResult payment(Payment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (payment != null) {
      return payment(this);
    }
    return orElse();
  }
}

abstract class Payment implements CartPresentationEvent {
  const factory Payment() = _$Payment;
}

/// @nodoc
class _$CartPresentationStateTearOff {
  const _$CartPresentationStateTearOff();

// ignore: unused_element
  NoClick noClick() {
    return const NoClick();
  }

// ignore: unused_element
  SummaryClick summaryClick() {
    return const SummaryClick();
  }

// ignore: unused_element
  AddressClick addressClick() {
    return const AddressClick();
  }

// ignore: unused_element
  DeliveryClick deliveryClick() {
    return const DeliveryClick();
  }

// ignore: unused_element
  PaymentClick paymentClick() {
    return const PaymentClick();
  }
}

/// @nodoc
// ignore: unused_element
const $CartPresentationState = _$CartPresentationStateTearOff();

/// @nodoc
mixin _$CartPresentationState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CartPresentationStateCopyWith<$Res> {
  factory $CartPresentationStateCopyWith(CartPresentationState value,
          $Res Function(CartPresentationState) then) =
      _$CartPresentationStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CartPresentationStateCopyWithImpl<$Res>
    implements $CartPresentationStateCopyWith<$Res> {
  _$CartPresentationStateCopyWithImpl(this._value, this._then);

  final CartPresentationState _value;
  // ignore: unused_field
  final $Res Function(CartPresentationState) _then;
}

/// @nodoc
abstract class $NoClickCopyWith<$Res> {
  factory $NoClickCopyWith(NoClick value, $Res Function(NoClick) then) =
      _$NoClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoClickCopyWithImpl<$Res>
    extends _$CartPresentationStateCopyWithImpl<$Res>
    implements $NoClickCopyWith<$Res> {
  _$NoClickCopyWithImpl(NoClick _value, $Res Function(NoClick) _then)
      : super(_value, (v) => _then(v as NoClick));

  @override
  NoClick get _value => super._value as NoClick;
}

/// @nodoc
class _$NoClick implements NoClick {
  const _$NoClick();

  @override
  String toString() {
    return 'CartPresentationState.noClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return noClick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (noClick != null) {
      return noClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return noClick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (noClick != null) {
      return noClick(this);
    }
    return orElse();
  }
}

abstract class NoClick implements CartPresentationState {
  const factory NoClick() = _$NoClick;
}

/// @nodoc
abstract class $SummaryClickCopyWith<$Res> {
  factory $SummaryClickCopyWith(
          SummaryClick value, $Res Function(SummaryClick) then) =
      _$SummaryClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$SummaryClickCopyWithImpl<$Res>
    extends _$CartPresentationStateCopyWithImpl<$Res>
    implements $SummaryClickCopyWith<$Res> {
  _$SummaryClickCopyWithImpl(
      SummaryClick _value, $Res Function(SummaryClick) _then)
      : super(_value, (v) => _then(v as SummaryClick));

  @override
  SummaryClick get _value => super._value as SummaryClick;
}

/// @nodoc
class _$SummaryClick implements SummaryClick {
  const _$SummaryClick();

  @override
  String toString() {
    return 'CartPresentationState.summaryClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SummaryClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return summaryClick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (summaryClick != null) {
      return summaryClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return summaryClick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (summaryClick != null) {
      return summaryClick(this);
    }
    return orElse();
  }
}

abstract class SummaryClick implements CartPresentationState {
  const factory SummaryClick() = _$SummaryClick;
}

/// @nodoc
abstract class $AddressClickCopyWith<$Res> {
  factory $AddressClickCopyWith(
          AddressClick value, $Res Function(AddressClick) then) =
      _$AddressClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddressClickCopyWithImpl<$Res>
    extends _$CartPresentationStateCopyWithImpl<$Res>
    implements $AddressClickCopyWith<$Res> {
  _$AddressClickCopyWithImpl(
      AddressClick _value, $Res Function(AddressClick) _then)
      : super(_value, (v) => _then(v as AddressClick));

  @override
  AddressClick get _value => super._value as AddressClick;
}

/// @nodoc
class _$AddressClick implements AddressClick {
  const _$AddressClick();

  @override
  String toString() {
    return 'CartPresentationState.addressClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is AddressClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return addressClick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (addressClick != null) {
      return addressClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return addressClick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (addressClick != null) {
      return addressClick(this);
    }
    return orElse();
  }
}

abstract class AddressClick implements CartPresentationState {
  const factory AddressClick() = _$AddressClick;
}

/// @nodoc
abstract class $DeliveryClickCopyWith<$Res> {
  factory $DeliveryClickCopyWith(
          DeliveryClick value, $Res Function(DeliveryClick) then) =
      _$DeliveryClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeliveryClickCopyWithImpl<$Res>
    extends _$CartPresentationStateCopyWithImpl<$Res>
    implements $DeliveryClickCopyWith<$Res> {
  _$DeliveryClickCopyWithImpl(
      DeliveryClick _value, $Res Function(DeliveryClick) _then)
      : super(_value, (v) => _then(v as DeliveryClick));

  @override
  DeliveryClick get _value => super._value as DeliveryClick;
}

/// @nodoc
class _$DeliveryClick implements DeliveryClick {
  const _$DeliveryClick();

  @override
  String toString() {
    return 'CartPresentationState.deliveryClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DeliveryClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return deliveryClick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deliveryClick != null) {
      return deliveryClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return deliveryClick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deliveryClick != null) {
      return deliveryClick(this);
    }
    return orElse();
  }
}

abstract class DeliveryClick implements CartPresentationState {
  const factory DeliveryClick() = _$DeliveryClick;
}

/// @nodoc
abstract class $PaymentClickCopyWith<$Res> {
  factory $PaymentClickCopyWith(
          PaymentClick value, $Res Function(PaymentClick) then) =
      _$PaymentClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentClickCopyWithImpl<$Res>
    extends _$CartPresentationStateCopyWithImpl<$Res>
    implements $PaymentClickCopyWith<$Res> {
  _$PaymentClickCopyWithImpl(
      PaymentClick _value, $Res Function(PaymentClick) _then)
      : super(_value, (v) => _then(v as PaymentClick));

  @override
  PaymentClick get _value => super._value as PaymentClick;
}

/// @nodoc
class _$PaymentClick implements PaymentClick {
  const _$PaymentClick();

  @override
  String toString() {
    return 'CartPresentationState.paymentClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PaymentClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult noClick(),
    @required TResult summaryClick(),
    @required TResult addressClick(),
    @required TResult deliveryClick(),
    @required TResult paymentClick(),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return paymentClick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult noClick(),
    TResult summaryClick(),
    TResult addressClick(),
    TResult deliveryClick(),
    TResult paymentClick(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (paymentClick != null) {
      return paymentClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult noClick(NoClick value),
    @required TResult summaryClick(SummaryClick value),
    @required TResult addressClick(AddressClick value),
    @required TResult deliveryClick(DeliveryClick value),
    @required TResult paymentClick(PaymentClick value),
  }) {
    assert(noClick != null);
    assert(summaryClick != null);
    assert(addressClick != null);
    assert(deliveryClick != null);
    assert(paymentClick != null);
    return paymentClick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult noClick(NoClick value),
    TResult summaryClick(SummaryClick value),
    TResult addressClick(AddressClick value),
    TResult deliveryClick(DeliveryClick value),
    TResult paymentClick(PaymentClick value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (paymentClick != null) {
      return paymentClick(this);
    }
    return orElse();
  }
}

abstract class PaymentClick implements CartPresentationState {
  const factory PaymentClick() = _$PaymentClick;
}
